<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link href="word.css" type="text/css" rel="stylesheet" />

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

</head>

<body>

  <div class="appwrapper">
    <div id="app">
      <div style="color: #fff; font-size: 30px; text-align: center; font-weight: bold;">{{ attempts_left }}</div>
      <div class="appwords">
        <div class="appwords__items">
          <div v-for="(row, row_index) in 6" :key="row" class="appwords__row">
            <div v-for="(col, col_index) in 5" :key="`${row}${col}`" class="appwords__col">
              <div class="appwords__cell" :class="checkCell(row_index, col_index)">
                <template v-if="isRowActive(row_index)">
                  {{ wordinput[col_index] }}
                </template>
                <template v-if="isRowAttemp(row_index)">
                  {{ appstate.attempts[row_index][col_index] }}
                </template>
              </div>
            </div>
          </div>
        </div>

        <div class="keyboard">
          <div v-for="(row, rowIndex) in keys" :key="rowIndex" class="keyboard__items">
            <div v-for="key in row" :key="key.label" :id="`key_${key.label}`" class="key"
              :class="{ 'special-key': key.isSpecial, 'disabled': key.disabled }" @click="handleKeyPress(key)"
              :style="{ width: key.width || '50px', textAlign:'center' }">
              {{ !key.isSpecial ? key.label: '' }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div><!-- /.appwrapper -->
  <script>
    const { createApp, ref, computed, reactive } = Vue

    const word = 'АФЕРА'
    const attempts = 6
    const allowed = true

    createApp({
      setup() {
        const word_letters = computed(() => word.split(''))
        const attempts_left = ref(attempts)
        const allowed_state = ref(allowed)
        const matches = ref([])
        const status = ref(false)
        let appstate = {}

        // если попыток менее 6, значит сегодня уже пытался отгадать, а значит берем состояние из хранилища
        if (attempts_left.value > 10) {
          getState()
        } else {
          appstate = {
            attempts: [], // слова из предыдущих попыток 
            letters_true: [], // отгаданные буквы
            letters_found: new Set(), // присутствующие буквы
            letters_false: new Set() // исключенные буквы
          }
        }


        // индекс текущей вводимой буквы
        const activeindex = ref(0)
        // номер попытки
        const activeattempt = ref(0)
        // текущее вводимое слово - массив введенных букв
        const wordinput = ref([])


        // клавиатура
        const keys = [
          [
            { label: 'Й' }, { label: 'Ц' }, { label: 'У' }, { label: 'К' }, { label: 'Е' },
            { label: 'Н' }, { label: 'Г' }, { label: 'Ш' }, { label: 'Щ' }, { label: 'З' },
            { label: 'Х' }, { label: 'Ъ' }
          ],
          [
            { label: 'Ф' }, { label: 'Ы' }, { label: 'В' }, { label: 'А' }, { label: 'П' },
            { label: 'Р' }, { label: 'О' }, { label: 'Л' }, { label: 'Д' }, { label: 'Ж' }, { label: 'Э' }
          ],
          [
            { label: 'enter', isSpecial: true, width: '92px', action: 'enter' },
            { label: 'Я' }, { label: 'Ч' }, { label: 'С' }, { label: 'М' }, { label: 'И' },
            { label: 'Т' }, { label: 'Ь' }, { label: 'Б' }, { label: 'Ю' },
            { label: 'backspace', isSpecial: true, width: '92px', action: 'backspace' }

          ]
        ]

        // загрузка текущего состояние в лок.хранилище если пользователь уже заходил сегодня
        const getState = () => {
          appstate = JSON.parse(localStorage.getItem('appstate'))
          attempts_left.value = JSON.parse(localStorage.getItem('attempts_left'))
        }
        // сохранение текущего состояние в лок.хранилище
        const saveState = (state) => {
          localStorage.setItem('appstate', JSON.stringify(state))
          localStorage.setItem('attempts_left', JSON.stringify(attempts_left.value))
        }
        // очистка состояние в лок.хранилище если у пользователя есть новая попытка
        const clearState = (state) => {
          localStorage.removeItem('appstate')
          localStorage.removeItem('attempts_left')
        }

        // проверка на активность ячейки 
        // слово - это номер попытки = строка, 
        // буква - это текущий активный индекс который сбрасывается при переходе к новой попытке (все буквы меньше этого индекса активны)
        const isCellActive = (col_index, row_index) => {
          return activeindex.value > col_index && activeattempt.value === row_index
        }

        const getCell = (row, col) => {
          return appstate.letters_true[row] ? appstate.letters_true[row][col] : null
        }

        // определение статуса каждой буквы
        const checkCell = (row_index, col_index) => {
          const cell_to_letter = getCell(row_index, col_index)
              console.log("cell_to_letter: ", cell_to_letter)

          if (cell_to_letter && cell_to_letter.letter) {
            const letter_input = cell_to_letter.letter 
            if (letter_input === word_letters.value[col_index]) {
              return 'successcell'
            } 
            if (appstate.letters_found.has(letter_input)) {
              return 'foundcell'
            }  
            if (appstate.letters_false.has(letter_input)) {
              return 'failcell'
            }
          }
          return ''
        }

        // провеврка если вообще нет такой буквы
        const isCellFail = (col_index, row_index) => {
          // соотвествие текущей ячейки массиву введенных букв
          const cell_to_letter = getCell(row_index, col_index)

          if (cell_to_letter) {
            return !word_letters.value.includes(cell_to_letter.letter)
          }
          return true
        }
        // провеврка есть ли такая буква вообще в слове
        const isCellFound = (col_index, row_index) => {

          // соотвествие текущей ячейки массиву введенных букв
          const cell_to_letter = getCell(row_index, col_index)

          if (cell_to_letter) {
            return word_letters.value.includes(cell_to_letter.letter)
          }
          return false
        }
        // провеврка есть ли в этой ячейке нужная буква
        // сохранять предыдущие отгаданные буквы
        const isCellSuccess = (col_index, row_index) => {

          // соотвествие текущей ячейки массиву введенных букв
          const cell_to_letter = getCell(row_index, col_index)

          if (cell_to_letter) {
            return cell_to_letter.letter === word_letters.value[col_index]
          }
          return false
        }
        // проверка в какой строке выводить текущее вводимое слово (текущая попытка = номер строки)
        const isRowActive = (row_index) => {
          return activeattempt.value === row_index
        }
        // проверка выводить ли в этой строке ранее введенное слово
        const isRowAttemp = (row_index) => {
          return activeattempt.value > row_index
        }

        const appfinish = () => {
          // если попытки закончились и слово не отгадано
          console.log('FAIL !!!!')
        }

        const appSuccess = () => {
          // если слово отагадано
          status.value = true
          console.log('SUCESS !!!!')
        }




        const findLetters = (word, input) => {
          // проверяем точные попадания букв в нужном месте
          matches.value = input.map((item, index) => {

            const letterstate = {
              letter: item,
              index,
              attemptnumber: activeattempt.value,
            }

            if (item === word[index]) {
              // если буква на нужном месте
              appstate.letters_found.add(item)

              return {
                ...letterstate,
                found: true
              }
            }
            else if (word.includes(item)) {
              // если буква есть где то в другом месте
              appstate.letters_found.add(item)
                return {
                ...letterstate,
                found: false
              }
            }
            else {
              // если буквы нет вообще
              appstate.letters_false.add(item)
                return {
                ...letterstate,
                found: false
              }
            }
          })
          appstate.letters_true.push(matches.value)

          if (matches.value.every(item => item !== undefined && item && item !== null && item.found === true)) {
            appSuccess()
          }

          console.log('matches: ', matches.value)
          console.log('appstate: ', appstate)
        }

      
        const checkAnswer = (word, input) => {
          if (input.length === word.length) {
            findLetters(word, input)


            activeattempt.value += 1
            activeindex.value = 0
            appstate.attempts.push([...input])
            wordinput.value = []
            saveState(appstate)

            attempts_left.value -= 1

            if (attempts_left.value < 1) {
              // не отгадано
              appfinish()
            }
          }
        }

        const removeLetter = () => {
          wordinput.value.pop()
          activeindex.value -= 1
        }

        const addLetter = (letter) => {
          wordinput.value.push(letter)
          activeindex.value += 1
        }


        const handleKeyPress = (key) => {
          if (status.value) {
            return
          }
          if (key.action) {
            if (key.action === 'enter') {
              checkAnswer(word_letters.value, wordinput.value)
            }
            if (key.action === 'backspace') {
              removeLetter()
            }
          } else {
            if (wordinput.value.length < 5) {
              addLetter(key.label)
            }
          }
        }

        return {
          word_letters,
          keys,
          wordinput,
          appstate,
          attempts_left,
         checkCell,
          isRowActive,
          isRowAttemp,
          handleKeyPress
        }
      }
    }).mount('#app')
  </script>
</body>

</html>