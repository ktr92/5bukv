<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link href="word.css" type="text/css" rel="stylesheet" />

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

</head>

<body>

  <div class="appwrapper">
    <div id="app">
      <div class="appwords">
        <div class="appwords__items">
          <div v-for="(row, row_index) in attempts_total" :key="row" class="appwords__row">
            <div v-for="(col, col_index) in word_length" :key="`${row}${col}`" class="appwords__col">
              <div class="appwords__cell" :class="checkCell(row_index, col_index)">
                <template v-if="isRowActive(row_index)">
                  {{ wordinput[col_index] }}
                </template>
                <template v-if="isRowAttemp(row_index)">
                  {{ appstate.value.attempts[row_index][col_index] }}
                </template>
              </div>
            </div>
          </div>
        </div>

        <div class="keyboard">
          <div v-for="(row, rowIndex) in keys" :key="rowIndex" class="keyboard__items">
            <div v-for="key in row" :key="key.label" :id="`key_${key.label}`" class="key"
              :class="{ 'special-key': key.isSpecial, 'disabled': key.disabled }" @click="handleKeyPress(key)"
              :style="{ width: key.width || '50px', textAlign:'center' }">
              {{ !key.isSpecial ? key.label: '' }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div><!-- /.appwrapper -->
  <script type="text/javascript">
    /**
     *
     */
    const { createApp, ref, computed, reactive } = Vue

    // загаданное слово
    const word = 'АФЕРА'
    // сколько попыток у пользователя в данной сессии
    const attempts = 6
    // можно ли этому пользователю сегодня играть 
    const allowed = true

    createApp({
      setup() {
        // исходное слово в виде массива букв
        const word_letters = computed(() => word.split(''))
        const attempts_left = ref(attempts)
        const attempts_total = ref(attempts)
        const allowed_state = ref(allowed)
        const word_length = computed(() => word.length)


        // в этом массиве будет храниться информация о совпадениях букв 
        // !!! в текущей попытке
        const matches = ref([])
        // статус приложение - отгадал слово или нет
        const status_success = ref(false)

        /**
         * Объект состояния приложения.
         * @typedef {Object} AppState
         * @property {Array<string>} attempts - слова из предыдущих попыток для вывода их в "таблице-кроссворде".
         * @property {Array<LetterState>} letters_true - информация о совпадениях букв (вся сессия).
         * @property {Set<string>} letters_found - присутствующие буквы.
         * @property {Set<string>} letters_false - отсутствующие буквы.
         */

        /**
         * Статус каждой буквы в попытке
         * @typedef {Object} LetterState
         * @property {String} letter - проверяемая буква
         * @property {Number} index - индекс проверяемой буквы
         * @property {boolean} found - отгадана или нет
         */

         /** 
         * Объект состояния приложения.
         * @type {AppState}
         */
        let appstate = reactive({})
        // если попыток менее 6, значит сегодня уже пытался отгадать, а значит берем состояние из хранилища
        if (attempts_left.value > 10) {
          getLocalState()
        } else {
          appstate.value= {
            attempts: [],
            letters_true: [], 
            letters_found: new Set(), 
            letters_false: new Set() 
          }
        }


        // индекс текущей вводимой буквы
        const activeindex = ref(0)
        // номер попытки = номер текущей активной строки
        const activeattempt = ref(0)
        // текущее вводимое слово - массив введенных букв
        const wordinput = ref([])

        // клавиатура
        const keys = [
          [
            { label: 'Й' }, { label: 'Ц' }, { label: 'У' }, { label: 'К' }, { label: 'Е' },
            { label: 'Н' }, { label: 'Г' }, { label: 'Ш' }, { label: 'Щ' }, { label: 'З' },
            { label: 'Х' }, { label: 'Ъ' }
          ],
          [
            { label: 'Ф' }, { label: 'Ы' }, { label: 'В' }, { label: 'А' }, { label: 'П' },
            { label: 'Р' }, { label: 'О' }, { label: 'Л' }, { label: 'Д' }, { label: 'Ж' }, { label: 'Э' }
          ],
          [
            { label: 'enter', isSpecial: true, width: '92px', action: 'enter' },
            { label: 'Я' }, { label: 'Ч' }, { label: 'С' }, { label: 'М' }, { label: 'И' },
            { label: 'Т' }, { label: 'Ь' }, { label: 'Б' }, { label: 'Ю' },
            { label: 'backspace', isSpecial: true, width: '92px', action: 'backspace' }

          ]
        ]

        /**
         *  загрузка текущего состояния из лок.хранилища если пользователь уже заходил сегодня
         */
        const getLocalState = () => {
          appstate.value= JSON.parse(localStorage.getItem('appstate'))
          attempts_left.value = JSON.parse(localStorage.getItem('attempts_left'))
        }
        /**
         * сохранение текущего состояние в лок.хранилище
         * @param {AppState} - состояние приложения
         */
        const saveState = (state) => {
          localStorage.setItem('appstate', JSON.stringify(state))
          localStorage.setItem('attempts_left', JSON.stringify(attempts_left.value))
        }
        /**
         * очистка состояние в лок.хранилище если у пользователя есть новая попытка
         */
        const clearState = () => {
          localStorage.removeItem('appstate')
          localStorage.removeItem('attempts_left')
        }
   
        /**
         * получить букву соотвествующую текущей ячейке
         * @param {number} row_index - строка "Таблицы"
         * @param {number} col_index - столбец "Таблицы"
         * @returns {LetterState} - состояние соотвествующей буквы для проверяемой ячейки
         */
        const getCell = (row_index, col_index) => {        
          return appstate.value.letters_true[row_index] ? appstate.value.letters_true[row_index][col_index] : null
        }
         

        // возможные значения классов для ячеек таблицы после проверки
         const CLASS_TYPES = {
          SUCCESS: 'successcell',
          FOUND: 'foundcell',
          FAIL: 'failcell',
          DEFAULT: ''
        };
        /**
         * определить класс для отображения буквы
         * @param {number} row_index - строка "Таблицы"
         * @param {number} col_index - столбец "Таблицы"
         * @returns {CLASS_TYPES} - состояние соотвествующей буквы для проверяемой ячейки
         */
        const checkCell = (row_index, col_index) => {
          const cell_to_letter = getCell(row_index, col_index)

          if (cell_to_letter && cell_to_letter.letter) {
            const letter_input = cell_to_letter.letter 
            if (letter_input === word_letters.value[col_index]) {
              return CLASS_TYPES.SUCCESS
            } 
            if (appstate.value.letters_found.has(letter_input)) {
              return CLASS_TYPES.FOUND
            }  
            if (appstate.value.letters_false.has(letter_input)) {
              return CLASS_TYPES.FAIL
            }
          }
          return CLASS_TYPES.DEFAULT
        }

        /**
         * проверка в какой строке выводить текущее вводимое слово (текущая попытка = номер строки)
         * @param {number} row_index - строка "Таблицы"
         * @returns {boolean} - в проверяемой строке или нет
         */
        const isRowActive = (row_index) => {
          return activeattempt.value === row_index
        }

        /**
         * проверка выводить ли в этой строке ранее введенное слово
         * @param {number} row_index - строка "Таблицы"
         * @returns {boolean} - в проверяемой строке или нет
         */
        const isRowAttemp = (row_index) => {
          return activeattempt.value > row_index
        }

        /**
         * конец игры при исчерпании попыток
         */
        const appfinish = () => {
          // если попытки закончились и слово не отгадано
          console.log('FAIL !!!!')
        }

         /**
         * конец игры при успешном отгадывании слова
         */
        const appSuccess = () => {
          // если слово отагадано
          status_success.value = true
          console.log('SUCESS !!!!')
        }

        /**
         * определении статуса букв во введенном слове
         * @param {Array<string>} word - искомое слово
         * @returns {Array<string>} - слово которое ввел пользователь
         */
        const findLetters = (word, input) => {
          matches.value = input.map((item, index) => {
            const letterstate = {
              letter: item,
              index
            }

            if (item === word[index]) {
              // если буква на нужном месте
              appstate.value.letters_found.add(item)

              return {
                ...letterstate,
                found: true
              }
            }
            else if (word.includes(item)) {
              // если буква есть где то в другом месте
              appstate.value.letters_found.add(item)
                return {
                ...letterstate,
                found: false
              }
            }
            else {
              // если буквы нет вообще
              appstate.value.letters_false.add(item)
                return {
                ...letterstate,
                found: false
              }
            }
          })
          // сохраняем статус данного слова
          appstate.value.letters_true.push(matches.value)

          // проверяем не угадано ли слово целиком
          if (matches.value.every(item => item !== undefined && item && item !== null && item.found === true)) {
            appSuccess()
          }

          console.log('matches: ', matches.value)
          console.log('appstate: ', appstate)
        }

        /**
         * проверка слова с продвижение далее к новой попытке
         * @param {Array<string>} word - искомое слово
         * @param {Array<string>} input -  слово которое ввел пользователь
         */
        const checkAnswer = (word, input) => {
          if (input.length === word.length) {
            // проверка букв
            findLetters(word, input)

            // смена шага-попытки
            activeattempt.value += 1
            activeindex.value = 0
            appstate.value.attempts.push([...input])
            wordinput.value = []
            attempts_left.value -= 1

            // после каждой попытки сохраняем состояние в локю хранилище чтобы пользователь не мог перезагрузить страницу и продлить попытки
            saveState(appstate)

            // проверяем не исчерпаны ли все попытки
            if (attempts_left.value < 1) {
              // не отгадано
              appfinish()
            }
          }
        }

        /**
         * обработка кнопки удаления буквы - уменьшение индекса текущего ввода
         */
        const removeLetter = () => {
          wordinput.value.pop()
          activeindex.value -= 1
        }

         /**
         * ввод буквы - смена индекса и добавление буквы в проверяемый массив букв (т.е. слово) 
         * @param {string} letter - вводимая буква
         */ 
        const addLetter = (letter) => {
          wordinput.value.push(letter)
          activeindex.value += 1
        }

        const KEY_STATUS = {
          DISABLED: 'key_disabled',
          SUCCESS: 'key_success',
          FOUND: 'key_found',
          DEFAULT: '',
        }
        const KEY_ACTION = {
          ENTER: 'enter',
          BACKSPACE: 'backspace'
        }

        /**
         * Объект кнопки клавиатуры
         * @typedef {Object} Key
         * @property {string} label - буква для кнопки 
         * @property {boolean} [isSpecial] - нестандартная кнопка, т.е. является ли эта кнопка функциональной, а не просто буквой
         * @property {string} [width] - нестандартная ширина буквы
         * @property {KEY_ACTION} [action] - идентификатор действия
         * @property {KEY_STATUS} [status] - статус кнопки после проверки на наличие этой буквы в слове
         */

         /**
         * обработка ввода буквы клавиатуры
         * @param {Key} key - нажатая кнопка
         */ 
        const handleKeyPress = (key) => {
          // если слово отгадано то больше ничего не вводим
          if (status_success.value) {
            return
          }
          if (key.action) {
            if (key.action === KEY_ACTION.ENTER) {
              checkAnswer(word_letters.value, wordinput.value)
            }
            if (key.action === KEY_ACTION.BACKSPACE) {
              removeLetter()
            }
          } else {
            // ввод букв
            if (wordinput.value.length < word_length.value) {
              addLetter(key.label)
            }
          }
        }

        return {
          attempts_total,
          word_length,
          word_letters,
          keys,
          wordinput,
          appstate,
          attempts_left,
          checkCell,
          isRowActive,
          isRowAttemp,
          handleKeyPress
        }
      }
    }).mount('#app')
  </script>
</body>

</html>